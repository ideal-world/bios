/***************************************************************************************
            THIS FILE IS MOSTLY GENERATED BY POEM-GRPC, DO NOT EDIT MANUALLY.
****************************************************************************************/ 


#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Metadata {
    #[prost(string, tag = "3")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub client_ip: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "7")]
    pub headers: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Payload {
    #[prost(message, optional, tag = "2")]
    pub metadata: ::core::option::Option<Metadata>,
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<::prost_types::Any>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigQueryRequest {
    #[prost(string, tag = "1")]
    pub data_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub group: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub tenant: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub tag: ::prost::alloc::string::String,
}
#[allow(unused_imports)]
#[::poem::async_trait]
pub trait Request: Send + Sync + 'static {
    async fn request(
        &self,
        request: poem_grpc::Request<Payload>,
    ) -> ::std::result::Result<poem_grpc::Response<Payload>, poem_grpc::Status>;
}
#[allow(unused_imports)]
#[derive(Clone)]
pub struct RequestServer<T>(::std::sync::Arc<T>);
impl<T: Request> poem_grpc::Service for RequestServer<T> {
    const NAME: &'static str = "Request";
}
#[allow(dead_code)]
impl<T> RequestServer<T> {
    pub fn new(service: T) -> Self {
        Self(::std::sync::Arc::new(service))
    }
}
impl<T: Request> ::poem::IntoEndpoint for RequestServer<T> {
    type Endpoint = ::poem::endpoint::BoxEndpoint<'static, ::poem::Response>;
    #[allow(clippy::redundant_clone)]
    #[allow(clippy::let_and_return)]
    fn into_endpoint(self) -> Self::Endpoint {
        use ::poem::endpoint::EndpointExt;
        let mut route = ::poem::Route::new();
        #[allow(non_camel_case_types)]
        struct RequestrequestService<T>(::std::sync::Arc<T>);
        #[::poem::async_trait]
        impl<T: Request> poem_grpc::service::UnaryService<Payload>
        for RequestrequestService<T> {
            type Response = Payload;
            async fn call(
                &self,
                request: poem_grpc::Request<Payload>,
            ) -> Result<poem_grpc::Response<Self::Response>, poem_grpc::Status> {
                self.0.request(request).await
            }
        }
        route = route
            .at(
                "/request",
                ::poem::endpoint::make({
                    let svc = self.0.clone();
                    move |req| {
                        let svc = svc.clone();
                        async move {
                            let codec = <poem_grpc::codec::ProstCodec<
                                _,
                                _,
                            > as ::std::default::Default>::default();
                            poem_grpc::server::GrpcServer::new(codec)
                                .unary(RequestrequestService(svc.clone()), req)
                                .await
                        }
                    }
                }),
            );
        let ep = route
            .before(|req| async move {
                if req.version() != ::poem::http::Version::HTTP_2 {
                    return Err(
                        ::poem::Error::from_status(
                            ::poem::http::StatusCode::HTTP_VERSION_NOT_SUPPORTED,
                        ),
                    );
                }
                Ok(req)
            });
        ep.boxed()
    }
}
#[allow(unused_imports)]
#[::poem::async_trait]
pub trait BiRequestStream: Send + Sync + 'static {
    async fn request_bi_stream(
        &self,
        request: poem_grpc::Request<poem_grpc::Streaming<Payload>>,
    ) -> ::std::result::Result<
        poem_grpc::Response<poem_grpc::Streaming<Payload>>,
        poem_grpc::Status,
    >;
}
#[allow(unused_imports)]
#[derive(Clone)]
pub struct BiRequestStreamServer<T>(::std::sync::Arc<T>);
impl<T: BiRequestStream> poem_grpc::Service for BiRequestStreamServer<T> {
    const NAME: &'static str = "BiRequestStream";
}
#[allow(dead_code)]
impl<T> BiRequestStreamServer<T> {
    pub fn new(service: T) -> Self {
        Self(::std::sync::Arc::new(service))
    }
}
impl<T: BiRequestStream> ::poem::IntoEndpoint for BiRequestStreamServer<T> {
    type Endpoint = ::poem::endpoint::BoxEndpoint<'static, ::poem::Response>;
    #[allow(clippy::redundant_clone)]
    #[allow(clippy::let_and_return)]
    fn into_endpoint(self) -> Self::Endpoint {
        use ::poem::endpoint::EndpointExt;
        let mut route = ::poem::Route::new();
        #[allow(non_camel_case_types)]
        struct BiRequestStreamrequest_bi_streamService<T>(::std::sync::Arc<T>);
        #[::poem::async_trait]
        impl<
            T: BiRequestStream,
        > poem_grpc::service::BidirectionalStreamingService<Payload>
        for BiRequestStreamrequest_bi_streamService<T> {
            type Response = Payload;
            async fn call(
                &self,
                request: poem_grpc::Request<poem_grpc::Streaming<Payload>>,
            ) -> Result<
                poem_grpc::Response<poem_grpc::Streaming<Self::Response>>,
                poem_grpc::Status,
            > {
                self.0.request_bi_stream(request).await
            }
        }
        route = route
            .at(
                "/requestBiStream",
                ::poem::endpoint::make({
                    let svc = self.0.clone();
                    move |req| {
                        let svc = svc.clone();
                        async move {
                            let codec = <poem_grpc::codec::ProstCodec<
                                _,
                                _,
                            > as ::std::default::Default>::default();
                            poem_grpc::server::GrpcServer::new(codec)
                                .bidirectional_streaming(
                                    BiRequestStreamrequest_bi_streamService(svc.clone()),
                                    req,
                                )
                                .await
                        }
                    }
                }),
            );
        let ep = route
            .before(|req| async move {
                if req.version() != ::poem::http::Version::HTTP_2 {
                    return Err(
                        ::poem::Error::from_status(
                            ::poem::http::StatusCode::HTTP_VERSION_NOT_SUPPORTED,
                        ),
                    );
                }
                Ok(req)
            });
        ep.boxed()
    }
}
