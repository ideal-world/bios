use tardis::poem_grpc;
use tardis::web::poem;

// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Metadata {
    #[prost(string, tag = "3")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub client_ip: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "7")]
    pub headers: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Payload {
    #[prost(message, optional, tag = "2")]
    pub metadata: ::core::option::Option<Metadata>,
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<::prost_types::Any>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigQueryRequest {
    #[prost(string, tag = "1")]
    pub data_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub group: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub tenant: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub tag: ::prost::alloc::string::String,
}
#[allow(unused_imports)]
pub trait Request: Send + Sync + 'static {
    fn request(&self, request: poem_grpc::Request<Payload>) -> impl ::std::future::Future<Output = ::std::result::Result<poem_grpc::Response<Payload>, poem_grpc::Status>> + Send;
}
#[allow(unused_imports)]
pub struct RequestServer<T> {
    inner: ::std::sync::Arc<T>,
    send_compressd: ::std::option::Option<poem_grpc::CompressionEncoding>,
    accept_compressed: ::std::sync::Arc<[poem_grpc::CompressionEncoding]>,
}
impl<T> ::std::clone::Clone for RequestServer<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self {
            inner: self.inner.clone(),
            send_compressd: self.send_compressd,
            accept_compressed: self.accept_compressed.clone(),
        }
    }
}
impl<T: Request> poem_grpc::Service for RequestServer<T> {
    const NAME: &'static str = "Request";
}
#[allow(dead_code)]
impl<T> RequestServer<T> {
    /// Create a new GRPC server
    pub fn new(service: T) -> Self {
        Self {
            inner: ::std::sync::Arc::new(service),
            send_compressd: ::std::option::Option::None,
            accept_compressed: ::std::sync::Arc::new([]),
        }
    }
    /// Set the compression encoding for sending
    pub fn send_compressed(self, encoding: poem_grpc::CompressionEncoding) -> Self {
        Self {
            send_compressd: Some(encoding),
            ..self
        }
    }
    /// Set the compression encodings for accepting
    pub fn accept_compressed(self, encodings: impl ::std::convert::Into<::std::sync::Arc<[poem_grpc::CompressionEncoding]>>) -> Self {
        Self {
            accept_compressed: encodings.into(),
            ..self
        }
    }
}
impl<T: Request> poem::IntoEndpoint for RequestServer<T> {
    type Endpoint = poem::endpoint::BoxEndpoint<'static, poem::Response>;
    #[allow(clippy::redundant_clone)]
    #[allow(clippy::let_and_return)]
    fn into_endpoint(self) -> Self::Endpoint {
        use poem::endpoint::EndpointExt;
        let mut route = poem::Route::new();
        #[allow(non_camel_case_types)]
        struct RequestrequestService<T>(::std::sync::Arc<T>);
        impl<T: Request> poem_grpc::service::UnaryService<Payload> for RequestrequestService<T> {
            type Response = Payload;
            async fn call(&self, request: poem_grpc::Request<Payload>) -> Result<poem_grpc::Response<Self::Response>, poem_grpc::Status> {
                self.0.request(request).await
            }
        }
        route = route.at(
            "/request",
            poem::endpoint::make({
                let server = self.clone();
                move |req| {
                    let server = server.clone();
                    async move {
                        let codec = <poem_grpc::codec::ProstCodec<_, _> as ::std::default::Default>::default();
                        poem_grpc::server::GrpcServer::new(codec, server.send_compressd, &server.accept_compressed).unary(RequestrequestService(server.inner.clone()), req).await
                    }
                }
            }),
        );
        let ep = route.before(|req| async move {
            if req.version() != poem::http::Version::HTTP_2 {
                return Err(poem::Error::from_status(poem::http::StatusCode::HTTP_VERSION_NOT_SUPPORTED));
            }
            Ok(req)
        });
        ep.boxed()
    }
}
#[allow(unused_imports)]
pub trait BiRequestStream: Send + Sync + 'static {
    fn request_bi_stream(
        &self,
        request: poem_grpc::Request<poem_grpc::Streaming<Payload>>,
    ) -> impl ::std::future::Future<Output = ::std::result::Result<poem_grpc::Response<poem_grpc::Streaming<Payload>>, poem_grpc::Status>> + Send;
}
#[allow(unused_imports)]
pub struct BiRequestStreamServer<T> {
    inner: ::std::sync::Arc<T>,
    send_compressd: ::std::option::Option<poem_grpc::CompressionEncoding>,
    accept_compressed: ::std::sync::Arc<[poem_grpc::CompressionEncoding]>,
}
impl<T> ::std::clone::Clone for BiRequestStreamServer<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self {
            inner: self.inner.clone(),
            send_compressd: self.send_compressd,
            accept_compressed: self.accept_compressed.clone(),
        }
    }
}
impl<T: BiRequestStream> poem_grpc::Service for BiRequestStreamServer<T> {
    const NAME: &'static str = "BiRequestStream";
}
#[allow(dead_code)]
impl<T> BiRequestStreamServer<T> {
    /// Create a new GRPC server
    pub fn new(service: T) -> Self {
        Self {
            inner: ::std::sync::Arc::new(service),
            send_compressd: ::std::option::Option::None,
            accept_compressed: ::std::sync::Arc::new([]),
        }
    }
    /// Set the compression encoding for sending
    pub fn send_compressed(self, encoding: poem_grpc::CompressionEncoding) -> Self {
        Self {
            send_compressd: Some(encoding),
            ..self
        }
    }
    /// Set the compression encodings for accepting
    pub fn accept_compressed(self, encodings: impl ::std::convert::Into<::std::sync::Arc<[poem_grpc::CompressionEncoding]>>) -> Self {
        Self {
            accept_compressed: encodings.into(),
            ..self
        }
    }
}
impl<T: BiRequestStream> poem::IntoEndpoint for BiRequestStreamServer<T> {
    type Endpoint = poem::endpoint::BoxEndpoint<'static, poem::Response>;
    #[allow(clippy::redundant_clone)]
    #[allow(clippy::let_and_return)]
    fn into_endpoint(self) -> Self::Endpoint {
        use poem::endpoint::EndpointExt;
        let mut route = poem::Route::new();
        #[allow(non_camel_case_types)]
        struct BiRequestStreamrequest_bi_streamService<T>(::std::sync::Arc<T>);
        impl<T: BiRequestStream> poem_grpc::service::BidirectionalStreamingService<Payload> for BiRequestStreamrequest_bi_streamService<T> {
            type Response = Payload;
            async fn call(
                &self,
                request: poem_grpc::Request<poem_grpc::Streaming<Payload>>,
            ) -> Result<poem_grpc::Response<poem_grpc::Streaming<Self::Response>>, poem_grpc::Status> {
                self.0.request_bi_stream(request).await
            }
        }
        route = route.at(
            "/requestBiStream",
            poem::endpoint::make({
                let server = self.clone();
                move |req| {
                    let server = server.clone();
                    async move {
                        let codec = <poem_grpc::codec::ProstCodec<_, _> as ::std::default::Default>::default();
                        poem_grpc::server::GrpcServer::new(codec, server.send_compressd, &server.accept_compressed)
                            .bidirectional_streaming(BiRequestStreamrequest_bi_streamService(server.inner.clone()), req)
                            .await
                    }
                }
            }),
        );
        let ep = route.before(|req| async move {
            if req.version() != poem::http::Version::HTTP_2 {
                return Err(poem::Error::from_status(poem::http::StatusCode::HTTP_VERSION_NOT_SUPPORTED));
            }
            Ok(req)
        });
        ep.boxed()
    }
}
