use tardis::poem_grpc;
use tardis::web::poem;

// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Metadata {
    #[prost(string, tag = "3")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub client_ip: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "7")]
    pub headers: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Payload {
    #[prost(message, optional, tag = "2")]
    pub metadata: ::core::option::Option<Metadata>,
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<::prost_types::Any>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigQueryRequest {
    #[prost(string, tag = "1")]
    pub data_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub group: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub tenant: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub tag: ::prost::alloc::string::String,
}
#[allow(unused_imports)]
pub trait Request: Send + Sync + 'static {
    fn request(&self, request: poem_grpc::Request<Payload>) -> impl ::std::future::Future<Output = ::std::result::Result<poem_grpc::Response<Payload>, poem_grpc::Status>> + Send;
}
#[allow(unused_imports)]
#[derive(Clone)]
pub struct RequestServer<T>(::std::sync::Arc<T>);
impl<T: Request> poem_grpc::Service for RequestServer<T> {
    const NAME: &'static str = "Request";
}
#[allow(dead_code)]
impl<T> RequestServer<T> {
    pub fn new(service: T) -> Self {
        Self(::std::sync::Arc::new(service))
    }
}
impl<T: Request> poem::IntoEndpoint for RequestServer<T> {
    type Endpoint = poem::endpoint::BoxEndpoint<'static, poem::Response>;
    #[allow(clippy::redundant_clone)]
    #[allow(clippy::let_and_return)]
    fn into_endpoint(self) -> Self::Endpoint {
        use poem::endpoint::EndpointExt;
        let mut route = poem::Route::new();
        #[allow(non_camel_case_types)]
        struct RequestrequestService<T>(::std::sync::Arc<T>);
        impl<T: Request> poem_grpc::service::UnaryService<Payload> for RequestrequestService<T> {
            type Response = Payload;
            async fn call(&self, request: poem_grpc::Request<Payload>) -> Result<poem_grpc::Response<Self::Response>, poem_grpc::Status> {
                self.0.request(request).await
            }
        }
        route = route.at(
            "/request",
            poem::endpoint::make({
                let svc = self.0.clone();
                move |req| {
                    let svc = svc.clone();
                    async move {
                        let codec = <poem_grpc::codec::ProstCodec<_, _> as ::std::default::Default>::default();
                        poem_grpc::server::GrpcServer::new(codec).unary(RequestrequestService(svc.clone()), req).await
                    }
                }
            }),
        );
        let ep = route.before(|req| async move {
            if req.version() != poem::http::Version::HTTP_2 {
                return Err(poem::Error::from_status(poem::http::StatusCode::HTTP_VERSION_NOT_SUPPORTED));
            }
            Ok(req)
        });
        ep.boxed()
    }
}
#[allow(unused_imports)]
pub trait BiRequestStream: Send + Sync + 'static {
    fn request_bi_stream(
        &self,
        request: poem_grpc::Request<poem_grpc::Streaming<Payload>>,
    ) -> impl ::std::future::Future<Output = ::std::result::Result<poem_grpc::Response<poem_grpc::Streaming<Payload>>, poem_grpc::Status>> + Send;
}
#[allow(unused_imports)]
#[derive(Clone)]
pub struct BiRequestStreamServer<T>(::std::sync::Arc<T>);
impl<T: BiRequestStream> poem_grpc::Service for BiRequestStreamServer<T> {
    const NAME: &'static str = "BiRequestStream";
}
#[allow(dead_code)]
impl<T> BiRequestStreamServer<T> {
    pub fn new(service: T) -> Self {
        Self(::std::sync::Arc::new(service))
    }
}
impl<T: BiRequestStream> poem::IntoEndpoint for BiRequestStreamServer<T> {
    type Endpoint = poem::endpoint::BoxEndpoint<'static, poem::Response>;
    #[allow(clippy::redundant_clone)]
    #[allow(clippy::let_and_return)]
    fn into_endpoint(self) -> Self::Endpoint {
        use poem::endpoint::EndpointExt;
        let mut route = poem::Route::new();
        #[allow(non_camel_case_types)]
        struct BiRequestStreamrequest_bi_streamService<T>(::std::sync::Arc<T>);
        impl<T: BiRequestStream> poem_grpc::service::BidirectionalStreamingService<Payload> for BiRequestStreamrequest_bi_streamService<T> {
            type Response = Payload;
            async fn call(
                &self,
                request: poem_grpc::Request<poem_grpc::Streaming<Payload>>,
            ) -> Result<poem_grpc::Response<poem_grpc::Streaming<Self::Response>>, poem_grpc::Status> {
                self.0.request_bi_stream(request).await
            }
        }
        route = route.at(
            "/requestBiStream",
            poem::endpoint::make({
                let svc = self.0.clone();
                move |req| {
                    let svc = svc.clone();
                    async move {
                        let codec = <poem_grpc::codec::ProstCodec<_, _> as ::std::default::Default>::default();
                        poem_grpc::server::GrpcServer::new(codec).bidirectional_streaming(BiRequestStreamrequest_bi_streamService(svc.clone()), req).await
                    }
                }
            }),
        );
        let ep = route.before(|req| async move {
            if req.version() != poem::http::Version::HTTP_2 {
                return Err(poem::Error::from_status(poem::http::StatusCode::HTTP_VERSION_NOT_SUPPORTED));
            }
            Ok(req)
        });
        ep.boxed()
    }
}
